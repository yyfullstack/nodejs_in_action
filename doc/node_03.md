## node 编程基础

#### 3.1 Node功能的组织及重用

- 如何创建模块
- 模块放在文件系统中的什么地方
- 在创建和使用模块时要意识到的东西

##### 3.1.1 创建模块

	模块既可能是一个文件，也可能是包含一个或多个文件的目录，如果模块是目录，Node通常会在这个目录下找一个叫index.js的文件作为模块的入口。
	
	典型的模块是一个包含exports对象属性定义的文件，这些属性可以是任意类型的数据，比如字符串、对象和函数。
	
	require 是Node中少数几个同步I/O操作之一。因为经常用到模块，并且一般都在文件顶端引入，所有把require做成同步的有助于保持代码的整洁、有序，还能增强可读性。但在程序中I/O密集的地方尽量不要用require。所有同步调用都会阻塞Node，直到调用完成才能做其他事情。比如你正在运行一个HTTP服务器，如果在每个进入的请求上都用了require，就会遇到性能问题。所以通常都只在程序最初加载时才使用require和其他同步操作。

##### 3.1.2 用 module.exports 微调模块的创建

	如果只需要从模块中得到一个函数，那从require中返回一个函数的代码要不返回一个对象的代码更优雅。
	
	要创建只返回一个变量或函数的模块，你可能会以为只要把exports设置成你想要返回的东西就行。但这样是不行的，因为Node觉得不能用任何其他对象、函数或变量给exports赋值。
**module.exports与exports的区别**

每一个node.js执行文件，都自动创建一个module对象，同时，module对象会创建一个叫exports的属性，初始化的值是 {}

```
 module.exports = {};
```

exports是引用 module.exports的值。module.exports 被改变的时候，exports不会被改变，而模块导出的时候，真正导出的执行是module.exports，而不是exports。exports在module.exports 被改变后失效。

	javascript里面有一句话，函数即对象，View 是对象，module.export =View, 即相当于导出整个view对象。外面模块调用它的时候，能够调用View的所有方法。不过需要注意，只有是View的静态方法的时候，才能够被调用，prototype创建的方法，则属于View的私有方法。其实是为了保证，模块的初始化环境是干净的。同时也方便我们，即使改变了 module.exports 指向的对象后，依然能沿用 exports的特性。

我们只需知道三点就知道 exports 和 module.exports 的区别了：

1. module.exports 初始值为一个空对象 {}
2. exports 是指向的 module.exports 的引用
3. require() 返回的是 module.exports 而不是 exports

我们经常看到这样的写法：

```
exports = module.exports = somethings
```

上面的代码等价于:

```
module.exports = somethings
exports = module.exports
```

##### 3.1.3 用 node_modules 重用模块

![1535164401430](H:\Node_workspace\nodejs_in_action\doc\1535164401430.png)

##### 3.1.4 注意事项

	尽管Node模块系统的本质简单直接，但还有两点需要注意一下。

第一，如果模块是目录，在模块目录中定义模块的文件必须命名为index.js、除非你在这个目录下一个叫package.json的文件里特别指明。要指定一个取代index.js的文件，package.json 文件里必须有一个用javascript对象表示法（JSON）数据定义的对象，其中有一个名为main的键，指明模块目录内文件的路径。

![1535164734111](H:\Node_workspace\nodejs_in_action\doc\1535164734111.png)

还有一点需要注意的是，Node能把模块作为对象缓存起来。如果程序中的两个文件引入了相同的模块，第一个文件会把模块返回的数据存到程序的内存中，这样第二个文件就不用再去访问和计算模块的源文件了。实际上第二个引入有机会修改缓存的数据。这种“猴子补丁”（monkey patching）让一个模块可以改变另一个模块的行为，开发人员可以不用创建它的新版本。

#### 3.2 异步编程技术

	如果你做过web前端编程，并且遇到过界面事件（如鼠标点击）触发的逻辑，那你就做过异步编程。服务端异步编程也一样：事件发生会触发响应逻辑。在Node的世界里流行两种响应逻辑管理方式：回调和事件监听。
	
	**回调**通常用来定义一次性响应的逻辑。如对于数据库查询，可以指定一个回调函数来确定如何查询结果。这个回调函数可能会显示数据库查询结果，根据这些结果来做些计算，或者以查询结果为参数执行另一个回调函数。
	
	事件监听器， 本质上也是一个回调，不同的是，它跟一个概念实体（事件）相关联。如，当有人在浏览器中点击鼠标时，鼠标点击是一个需要处理的事件。在Node中，当有HTTP请求过来，HTTP服务器会发出一个请求事件。你可以监听那个请求事件，并添加一些响应逻辑。
	
	一个Node HTTP服务器实例就是一个事件发射器，一个可以继承、能够添加事件发射及处理能力的类（EventEmitter）。Node的很多核心功能都继承自EventEmitter，你也可以创建自己的事件发射器。
	
	Node 有两种常用的响应逻辑组织方式，我们已经用其中一种构建了响应逻辑，现在该了解一下它是如何实现的了。

- 如何用回调处理一次性事件
- 如果用事件监听器响应重复事件
- 异步编程的几个难点

##### 3.2.1 用回调处理一次性事件

	回调是一个函数，它被当做参数传给异步函数，它描述了异步操作完成之后要做什么。回调在Node开发中用的很频繁，比事件发射器用的多，并且用起来也很简单。
	
	例子嵌入了三层回调，三层还算可以，但回调层数越多，代码看起来越乱，重构和测试起来也越困难， 所以最好限制一下回调的嵌套层级。如果把每一层回调嵌套的处理做成命名函数，虽然表示相同逻辑所用的代码变多了，但维护、测试和重构起来会更容易。
	
	创建中间函数以减少嵌套，你还可以用Node开发中的另一种惯用法：减少由if/else 引起的嵌套：尽早从函数中返回。
	
	Node中的大多数内置模块在使用回调时都会带两个参数：第一个是用来放可能会发生的错误的，第二个是放结果的。错误参数经常被错写为er或err。

##### 3.2.2 用事件发射器处理重复性事件

	事件发射器会触发事件，并且在那些事件被触发时能处理它们。一些重要的Node API 组件，比如HTTP服务器、TCP服务器和流，都被做成了事件发射器。你也可以创建自己的事件发射器。

错误处理：在错误处理上有个常规做法，你可以创建发出error类型事件的事件触发器，而不是直接抛出错误。这样就可以为这一事件类型设置一个或多个监听器，从而定义定制的事件响应逻辑。

```
var events = require('events');
var myEmitter = new events.EventEmitter();
myEmitter.on('error', function(err){
    console.log('Error: ' + err.message);
});

myEmitter.emit('error', new Error('Something is wrong.'));
```

 	如果这个error事件类型被发出时没有该事件类型的监听器，事件发射器会输出一个堆栈跟踪（到错误发生时所执行过的程序指令列表）并停止执行。堆栈跟踪会用emit调用的第二个参数指明错误类型。这是只有错误类型时间才能享受的特殊待遇，在发出没有监听器的其他事件类型时，什么也不会发生。

	如果发出的error类型事件没有作为第二个参数的error对象，堆栈跟踪会指出一个“未捕获、未指明的‘错误’事件” 错误，并且程序会停止执行。你可以用一个已经被废除的方法处理这个错误。用下面的代码定义一个全局处理器实现响应逻辑：
	
	process.on('uncaugthtException', function(err){
	    console.error(err.stack);
	    process.exit(1);
	})
为了增加能够附加到事件发射器上的监听器数量，不让Node在监听器数量超过10个时向你发出警告，可以用setMaxListeners方法。以频道事件发射器为例，可以用下面的代码增加监听器的数量： channel.setMaxListeners(50)

	**4.扩展事件监听器：文件监视器**

如果你想在事件发射器的基础上构建程序，可以创建一个新的javascript类继承事件发射器。比如创建一个Watcher类来处理放在某个目录下的文件。然后可以用这个类创建一个工具，该工具可以监视目录（将放到里面的文件名都改成小写），并将文件复制到一个单独目录中。

	通过学习如何使用回调定义一次性异步逻辑，以及如何使用事件发射器重复派发异步逻辑，你离掌握Node程序的行为又近一步了。然而你可能还想在单个回调或事件发射器的监听器中添加新的异步任务。如果这些任务的执行顺序很重要，你就会面对新的难题：如何准确控制一系列异步任务里的每个任务。

##### 3.2.3 异步开发的难题

	在创建异步程序是，你必须密切关注程序的执行流程，并瞪大眼睛盯着程序的状态：事件轮询的条件、程序变量，以及其他随着程序逻辑执行而发生变化的资源。
	
	比如说，Node的事件轮询会跟踪还没有完成的异步逻辑。只要有未完成的异步逻辑，Node进程就不会退出。一个持续执行的Node进程对Web服务器之类的应用来说很有必要，但对于命令行工具这种经过一段时间后就应该结束的应用却意义不大。事件轮询会跟踪所有数据库连接，直到它们关闭，以防止Node退出。

#### 3.3 异步逻辑的顺序化

	在异步程序的执行过程中，有些任务可能会随时发生，跟程序中的其他部分在做什么没关系，什么时候做这些任务都不会出问题。但也有些任务只能在某些特定的任务之后做。
	
	让一组异步任务顺序执行的概念被Node社区称为流程控制。这种控制分为两类：串行和并行
	
	![1535423454876](H:\Node_workspace\nodejs_in_action\doc\1535423454876.png)
	
	需要一个接一个做的任务叫做串行任务。创建一个目录并往里放一个文件的任务就是串行的。你不能在创建目录前往里放文件。
	
	不需要一个接一个做的任务叫做并行任务。这些任务彼此之间开始和结束的时间并不重要，但在后续逻辑执行之前它们应该全部做完。下载几个文件然后把它们压缩到一个zip归档文件中的任务就是并行任务。这些文件的下载可以同时进行，但在创建文档文件之前应该全部下载完。
	
	跟踪串行和并行的流程控制要做编程记账的工作。在实现串行化流程控制时，需要跟踪当前执行的任务，或维护一个尚未执行的任务的队列。实现并行化流程控制时需要跟踪有多少个任务要执行完成了。
	
	有一些可以帮你记账的流程控制工具，它们能让组织异步的串行或并行化任务变得很容易。
##### 3.3.1 什么时候使用串行流程控制

可以使用回调让几个异步任务按顺序执行，但如果任务很多，必须组织一些，否则过多的回调嵌套会把代码搞的很乱。

##### 3.3.2 实现串行化流程控制

	为了用串行化流程控制让几个异步任务按顺序执行，需要先把这些任务按预期的执行顺序放到一个数组中。这个数组将起到队列的作用：完成一个任务后按顺序从数组中取出下一个。

![1535425260065](H:\Node_workspace\nodejs_in_action\doc\1535425260065.png)

	数组中的每个任务都是一个函数。任务完成后应该调用一个处理器函数，告诉它错误状态和结果。如果有错误，处理器函数会终止执行；如果没有错误，处理器就从队列中取出下一个任务执行它。

##### 3.3.3 实现并行化流程控制

	为了让异步任务并行执行，仍然是要把任务放到数组中，但任务的存放顺序无关紧要。每个任务都应该调用处理器函数增加已完成任务的计数值。当所有任务都完成后，处理器函数应该执行后续的逻辑。

##### 3.3.4 利用社区里的工具

	社区中的很多附加模块都提供了方便好用的流程控制工具。其中比较流行的有Nimble、Step和Seq三个。

