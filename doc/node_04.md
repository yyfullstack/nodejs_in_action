## 构建Node Web 程序

#### 4.1 Http服务器的基础知识

Node的核心是一个强大的流式HTTP解析器，大概由1500行经过优化的C代码组成，是Node的作者Ryan Dahl写的。这个解析器跟Node开放给Javascript的底层TCP API相结合。为你提供了一个非常底层，但也非常灵活的HTTP服务器。

跟Node的大多数核心模块一样，http模块也很简单。高层的“含糖” API被留给了Connect或Express这样的第三方框架，这样极大地简化了Web程序的构建过程。



	![1535444653304](H:\Node_workspace\nodejs_in_action\doc\1535444653304.png)

##### 4.1.1 Node 如何向开发者呈现HTTP请求

创建HTTP服务器要调用http.createServer() 函数。它只有一个参数，是个回调函数，服务器每次收到HTTP请求后都会调用这个回调函数。这个请求回调函数收到两个参数，请求和响应对象，通常简写req和res：

```javascript
var http = require('http');
var server = http.ceateServer(function(req, res){
    //处理请求
})
```

服务器每收到一条http请求，都会用新的req和res对象触发请求回调函数。在触发回调函数之前，Node会解析请求的HTTP头，并将它们作为req对象的一部分提供给请求回调。但Node不会再回调函数被触发之前开始对请求体的解析。这种做法跟某些服务端框架不同，如PHP就是在程序逻辑运行前就把请求头和请求体都解析出来了。Node提供了这个底层接口，所以如果你想的话，可以在请求体正被解析时处理其中的数据。

Node不会自动往客户端写任何响应。在调用完请求回调函数之后，就要由你负责用res.end() 方法结束响应了。这样在结束响应之前，你可以在请求的生命周期内运行任何你想运行的异步逻辑。如果你没能结束响应，请求会挂起，直到客户端超时，或者它会一直处于打开状态。

![1535446351133](H:\Node_workspace\nodejs_in_action\doc\1535446351133.png)

##### 4.1.3 读取请求头及设定响应头

Node提供了几个修改HTTP响应头的方法：res.setHeader(field, value); res.getHeader(field)和res.removeHeader(field)。添加和移除响应头的顺序可以随意，但一个要在调用res.write()或res.end（）之前。在响应主体的第一个部分写入之后，Node会刷新已经设定好 HTTP头。

##### 4.1.4 设置HTTP响应的状态码

我们经常需要返回默认状态码200之外的HTTP状态码。比较常见的情况是当所请求的资源不存在时返回一个404 NotFound 状态码。

这要设定res.statusCode 属性。在程序响应期间可以随时给这个属性赋值，只要是在第一次调用res.write()或res.end()之前就行。

Node的策略是提供小而强的网络API，不去跟Rails或Django之类的框架竞争，而是作为类似框架构建基础的巨大平台。因为这种设计理念，像会话这种高级概念以及HTTP cookies这样的基础组件都没有包括在Node的内核之中。那些都要第三方模块提供。

#### 4.2 构建RESTful Web 服务

假设你想用Node创建一个待办事项清单的Web服务，涉及到典型的创建、读取、更新和删除（CRUD）操作。执行操作的实现方式有很多种，但本节要创建一个RESTful Web服务，一个使用HTTP方法谓词提供精简API的服务。

HTTP1.0和HTTP1.1规范的突出贡献者之一，Roy Fielding 博士在2000年提出 了表征状态转移（REST）。依照惯例，HTTP谓词，如GET、POST、PUT和DELETE。分别跟由URL指定的资源的获取、创建、更新和移除相对应。RESTful Web 服务之所以得以流行，是因为它们的使用和实现比简单对象访问协议（SOAP）之类的协议更简单。

创建标准的REST 服务器需要实现四个HTTP谓词。每个谓词会覆盖一个待办事项清单的操作任务：

- POST  向待办事项清单中添加事项；
- GET 显示当前事项列表，或者显示某一事项的详情
- DELETE 从待办事项清单中移除事项；
- PUT 修改已有事项，

**设定Content-Length头**

为了提高响应速度，如果可能的话，应该在响应中带着Content-Length域一起发送。对于事项清单而言，响应主体很容易在内存中提前构建好，所有你能得到字符串的长度并一次性地将整个清单发出去。设定Content-Length域会隐含禁用Node的块编码，因为要传输的数据更少，所以能提升性能。

你可能想用body.length的值设定Content-Length，但Content-Length的值应该是字节长度，不是字符长度，并且如果字符串中有多字节字符，两者的长度是不一样的。为了规避这个问题，Node提供了一个Buffer.byteLength()方法。

##### 4.2.3 用DELETE 请求移除资源

最后是用DELETE 移除事项，为了完成这个任务，程序需要检查请求的URL，HTTP客户端会在其中指明要移除哪个事项。

先对输入值做检查，因为你永远不能相信用户输入数据的有效性，然后它对请求做出了响应。如果这个数字是“非数字”（javascript 值NaN），状态码会被设置成400，表明这是一个坏请求。接着是检查事项是否存在，如果不存在就用404 Not Found做响应。

#### 4.3 提供静态文件服务

##### 4.3.1  创建一个静态文件服务器

像Apache和IIS之类的传统的HTTP服务器首先是个文件服务器，现在你手上可能有个老网站跑在这样的文件服务器上，把它移植过来，在Node上复制这个基本功能对你理解过去所有的HTTP服务器很有帮助。

\_\_dirname 在Node中是一个神奇的变量，它的值是该文件所在的目录的路径。\_\_dirname的神奇之处在于，它在同一个程序中可以有不同的值，如果你有分散在不同目录中的文件的话。

**用Stream.pipe() 优化数据传输**

尽管了解fs.ReadStreamd 的工作机制以及它那种事件方式的灵活性很重要，但Node还提供了更高级的实现机制：Stream.pipe()。用这个方法可以极大地简化服务器的代码。

**管道和水管**

```
把Node中的管道想象成水管对你理解这个概念很有帮助。比如你想让某个源头（如热水器）流出来的水流到一个目的地（如厨房），可以在中间加一个管道把它们连起来，这样水就会顺着管道从源头流到目的地。
Node在的管道也是这样，但其中流动的不是水，而是来自源头（即ReadableStream）的数据，管道可以让它们流动到某个目的地（即WritableStream）。你可以用Pipe方法把管道连起来。
ReadableStream.pipe(WritableStream);

如读取文件并把内容写入另一个文件：
var readStream = fs.createReadStream('./r1.txt');
var writeStream = fs.createWriteStream('./w1.txt');
readStream.pipe(writeStream);

把http请求写入文件中：
req.pipe(fs.createWriteStream('./w1.txt'));
```

##### 4.3.2 处理服务器错误

在Node中，所有继承了EventEmitter的类都可能会发出error事件，像fs.ReadStream这样的流只是专用的EventEmitter，有预先定义的data和end等事件。默认情况下，如果没有设置监听器，error事件会被抛出。为了防止服务器被错误搞垮，我们要监听错误。

##### 4.3.3 用fs.stat（）实现先发制人的错误处理

因为传输的文件是静态的，所以我们可以用stat() 系统调用获取文件的相关信息，比如修改时间、字节数等。在提供条件式GET支持时，这些信息特别重要，浏览器可以发起请求检查它的缓存是否过期了。

#### 4.4 从表单中接收用户输入

##### 4.4.1 处理提交的表单域

表单提交请求带的Content-Type值通常有两种：

- application/x-www-form-urlencoded：这是HTML表单的默认值，
- multipart/form-data, 在表单中含有文件或非ASCII或二进制数据时使用。

缓存太多数据:  对于包含一点JSON、XML或类似小块数据的请求主体，缓冲很好用，但缓冲这个数据可能会有问题。如果缓冲区的大小设置不正确，很可能会让程序出现可用性漏洞，这个我们在后面讨论。因此，比较好的做法是实现一个流式解析器，降低对内存的要求，防止过度消耗资源。尽管更难使式用和实现，但这个处理会随着数据块不断发出做增量解析。

#### 4.5 用HTTPS 加强程序的安全性

对于电子商务网站，以及那些会涉及到敏感数据的网站来说，一般都要求能够保证服务器往来的数据是私密的。在标准的HTTP会话中，客户端跟服务器端用未经加密的文本交换信息。这使得HTTP通信很容易被窃听。

安全的超文本传输协议（HTTPS）提供了一种保证web会话私密性的方法。HTTPS将HTTP和TLS/SSL传输层结合到一起。用HTTPS发送的数据是经过加密的，因此更难窃听。

如果你想在你的Node程序里使用HTTPS，第一件事就是取得一个私钥和一份证书。私钥本质上是个“密钥”，可以用它来解密客户端发给服务器的数据。私有保存在服务器上的一个文件里，放在一个不可信用户无法轻易访问到的地方。这种SSL证书不能用在正式网站上，因为当用户访问带有不可信证书的页面时，浏览器会显示警告信息，但对于开发和测试经过加密的通信而言，它很实用。

生成私钥需要OpenSSL,在装Node时就已经装过了，输入下面的命令会生成一个名为key.pem的私钥文件：

```c
openssl genrsa 1024 > key.pem 
```

除了私钥，你还需要一份证书。证书跟私钥不同，可以与全世界分享，它包含了公钥和证书持有者的信息。公钥用来加密从客户端发往服务器的数据。

创建证书需要私钥。输入下面的命令会生成一个名为key-cert.pem 的证书

```
openssl req -x509 -new -key key.pem > key-cert.pem
```

秘钥已经生成了，把它们放到一个安全的地方。